{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>YSAutoML Total Pipeline</title>
  <style>
    body { margin:0; font-family:Inter, sans-serif; background:#1B1B1B; color:#FAF1E4; display:flex; }

    /* Sidebar */
    .sidebar {
      position: fixed;
      top: 0;
      left: 0;
      height: 100vh;
      overflow-y: auto;
      width: 250px;
      background: #111;
      padding: 20px;
      z-index: 1000; /* âœ… ê²¹ì¹  ë•Œ ìœ„ì— ì˜¤ì§€ ì•Šë„ë¡ ëª…ì‹œ */
    }

    .content {
      flex: 1;
      padding: 20px;
      margin-left: 300px; /* âœ… sidebarë§Œí¼ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ë°€ê¸° */
      box-sizing: border-box;
      min-width: calc(100% - 300px); /* âœ… ì½˜í…ì¸ ê°€ ì˜ë¦¬ì§€ ì•Šê²Œ */
    }

    .sidebar h1 { font-size:22px; margin-bottom:5px; }
    .sidebar p { font-size:12px; color:#aaa; margin-bottom:30px; }
    .menu-item { padding:10px 15px; cursor:pointer; border-radius:6px; transition:background 0.2s; margin-bottom:5px; }
    .menu-item:hover { background:#1F1F1F; }
    .menu-item.active { background:#1F53FF; color:white; }

    .logo-link { color:#FAF1E4; text-decoration:none; cursor:pointer; }
    .logo-link:hover { color:#FAF1E4; }

    a {
      color: #FAF1E4;
      text-decoration: none;
    }

    a:hover {
      color: #1F53FF; /* hover ì‹œ í¬ì¸íŠ¸ ìƒ‰ */
    }


    /* Content */
    /* .content { flex:1; padding:20px; } */
    .topbar {
      position: fixed;          /* âœ… í™”ë©´ ìƒë‹¨ ê³ ì • */
      top: 0;                   /* âœ… ìœ„ì—ì„œ 0px */
      right: 0;                 /* ì˜¤ë¥¸ìª½ ì •ë ¬ */
      left: 300px;              /* sidebar í­ë§Œí¼ ë„ì›€ */
      height: 60px;             /* í•„ìš”ì‹œ ê³ ì • ë†’ì´ */
      background: #1B1B1B;      /* ë°°ê²½ìƒ‰ ê¹”ì•„ì„œ ê°€ë ¤ì§€ì§€ ì•Šê²Œ */
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 10px;
      padding: 0 20px;
      z-index: 1001;            /* sidebarë³´ë‹¤ ì‚´ì§ ìœ„ */
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }

    .btn-train { background:#1F53FF; border:none; padding:10px 20px; color:#fff; border-radius:6px; cursor:pointer; }
    .btn-stop { background:#d32f2f; border:none; padding:10px 20px; color:#fff; border-radius:6px; cursor:pointer; }

    /* Form layout */
    .form-grid { display:grid; grid-template-columns:repeat(auto-fill,minmax(300px,1fr)); gap:16px; margin-top: 50px;}
    .form-card { background:#1F1F1F; padding:16px; border-radius:10px; box-shadow:0 0 6px rgba(0,0,0,0.3); }
    .form-card h3 { font-size:14px; font-weight:600; margin-bottom:10px; color:#EAEAEA; }
    .form-card select, .form-card input { width:100%; padding:10px; background:#262626; border:1px solid #333; border-radius:6px; color:#FAF1E4; font-size:14px; }

    .radio-group, .checkbox-group { display:flex; flex-direction:column; gap:6px; width:100%; }
    .radio-group label, .checkbox-group label { display:flex; align-items:center; white-space:nowrap; gap:10px; }
    .radio-group label span, .checkbox-group label span { display:inline-block; min-width:100px; }
    .radio-group input, .checkbox-group input { margin-left:auto; accent-color:#1F53FF; }

    label { font-size:14px; cursor:pointer; }

    /* âœ… Log & Result */
    .logbox {
      background:#000;
      color:#0f0;
      font-family:monospace;
      height:220px;
      overflow-y:scroll;
      margin-top:20px;
      padding:10px;
      border-radius:8px;
      white-space: pre-wrap;  /* âœ… ì¤„ë°”ê¿ˆ ë°˜ì˜ */
      line-height: 1.4;
    }

    table { width:100%; border-collapse:collapse; margin-top:20px; background:#262626; border-radius:8px; overflow:hidden; }
    th, td { padding:10px; border-bottom:1px solid #333; text-align:left; }
    th { background:#333; }

    .btn-small {
      background:#333;
      border:none;
      padding:6px 10px;
      border-radius:6px;
      color:#FAF1E4;
      cursor:pointer;
      font-size:13px;
    }
    .btn-small:hover { background:#1F53FF; color:#fff; }

    #graphViewerWrapper {
      display: inline-block;
      position: relative;
      overflow: hidden;
      width: 200%; /* form-cardì˜ 2ë°° ë„ˆë¹„ */
      max-width: 1600px; /* ìµœëŒ€ í•œê³„ */
      height: 600px; /* ê³ ì • ë†’ì´ ì œí•œ */
      border: 1px solid #333;
      border-radius: 8px;
      background-color: #111;
      cursor: grab;
    }

    #modelGraphImage {
      width: 100%;
      height: auto;
      transform-origin: center center;
      transition: transform 0.1s ease-out;
      user-select: none;
      -webkit-user-drag: none;
    }


  </style>
  <!-- âœ… CSRF í† í°ì„ ê°€ì ¸ì˜¤ëŠ” ìœ í‹¸ í•¨ìˆ˜ ì¶”ê°€ -->
  <script>
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    // âœ… ì „ì—­ ë³€ìˆ˜ë¡œ CSRF í† í° ì €ì¥
    const csrftoken = getCookie('csrftoken');
  </script>
</head>
<body>

  <!-- Sidebar -->
  <div class="sidebar">
    <h1><a href="/" class="logo-link">YSAutoML</a></h1>
    <p>Total Model Pipeline</p>
    <div class="menu">
      <div class="menu-item active" id="total-menu">Total</div>
    </div>
  </div>

  <!-- Content -->
  <div class="content">
    <div class="topbar">
      <button class="btn-train" id="runBtn">Run Total Pipeline</button>
      <button class="btn-stop" id="stopBtn">Stop Process</button>
    </div>

    <form id="totalForm" class="form-grid">
      <!-- Model -->
      <div class="form-card">
        <h3>Model</h3>
        <select name="model">
          <option value="AutoFormer">AutoFormer</option>
          <option value="ResNet18">ResNet18</option>
          <option value="MobileNetV2">MobileNetV2</option>
        </select>
      </div>

      <!-- Config -->
      <div class="form-card">
        <h3>Config</h3>
        <label>Epochs <input type="number" name="epochs" value="50"></label>
        <label>Learning Rate <input type="number" step="0.0001" name="lr" value="0.001"></label>
        <label>Seed <input type="number" name="seed" value="42"></label>
        <label>Device <input type="text" name="device" value="cuda:0"></label>
      </div>

      <!-- Data -->
      <div class="form-card">
        <h3>Data (multiple allowed)</h3>
        <div class="checkbox-group">
          <label><span>FYI</span><input type="checkbox" name="data" value="fyi"></label>
          <label><span>DSBN</span><input type="checkbox" name="data" value="dsbn"></label>
        </div>
      </div>

      <!-- Network -->
      <div class="form-card">
        <h3>Network (select one)</h3>
        <div class="radio-group">
          <label><span>Few-shot</span><input type="radio" name="network" value="fewshot" checked></label>
          <label><span>One-shot</span><input type="radio" name="network" value="oneshot"></label>
          <label><span>Zero-shot</span><input type="radio" name="network" value="zeroshot"></label>
        </div>
      </div>

      <!-- NAS Config (Zero-shot only) -->
      <div class="form-card" id="nasConfigBox" style="display:none;">
        <h3>NAS Config</h3>

        <!-- GPU & SEED -->
        <label>GPU ID <input type="number" name="gpu" value="0" /></label>
        <label>Seed <input type="number" name="seed" value="123" /></label>

        <!-- Metric -->
        <label>Metric
          <select name="metric">
            <option value="AZ_NAS">AZ_NAS</option>
            <option value="SynFlow">SynFlow</option>
            <option value="GradNorm">GradNorm</option>
          </select>
        </label>

        <!-- Population & Iteration -->
        <label>Population Size <input type="number" name="population_size" value="100" /></label>
        <label>Evolution Max Iter <input type="number" name="evolution_max_iter" value="100" /></label>

        <!-- Resolution -->
        <label>Resolution <input type="number" name="resolution" value="224" /></label>

        <!-- Budget FLOPs -->
        <label>Budget FLOPs (Ã—1e6):</label>
        <input type="range" id="flopsSlider" min="50" max="1000" step="50" value="1000" />
        <p id="flopsValue" style="margin-top:8px;">Current: 1000e6</p>

        <div style="display:flex; gap:8px; margin-top:10px;">
          <button type="button" class="btn-small" id="flopsSmall">Small (450e6)</button>
          <button type="button" class="btn-small" id="flopsMedium">Medium (600e6)</button>
          <button type="button" class="btn-small" id="flopsLarge">Large (1000e6)</button>
        </div>
        <input type="hidden" name="budget_flops" id="budgetFlopsHidden" value="1000e6" />

        <!-- Max Layers / Batch Size -->
        <label>Max Layers <input type="number" name="max_layers" value="16" /></label>
        <label>Batch Size <input type="number" name="batch_size" value="32" /></label>

        <!-- Data Path -->
        <label>Data Path <input type="text" name="data_path" value="/dataset/ILSVRC2012/" /></label>
      </div>



      <!-- Optimization -->
      <div class="form-card">
        <h3>Optimization (select one)</h3>
        <div class="radio-group">
          <label><span>FXP</span><input type="radio" name="optimization" value="fxp" checked></label>
          <label><span>Loss Search</span><input type="radio" name="optimization" value="losssearch"></label>
          <label><span>MTL</span><input type="radio" name="optimization" value="mtl"></label>
        </div>
      </div>
      
      <div id="modelGraphBox" style="margin-top:30px; display:none; text-align:center;">
        <h4>ğŸ§© Model Architecture Graph</h4>
        <div id="graphViewerWrapper">
          <img id="modelGraphImage" src="" alt="Model Graph" />
        </div>
      </div>

    </form>

    
      <!-- FXP Config Upload -->
      <div id="fxpUploadBox" style="margin-top:30px;">
        <h3>âš™ï¸ FXP Optimization Config</h3>
        <form id="fxpForm" enctype="multipart/form-data">
          <label>FXP Config File (.yml)
            <input type="file" name="config_file" accept=".yml,.yaml" required lang="en">
          </label>
        </form>
      </div>




    <div class="logbox" id="logBox"></div>

    <table id="resultTable" style="display:none;">
      <thead><tr><th>Stage</th><th>Status</th><th>Log / Checkpoint</th></tr></thead>
      <tbody></tbody>
    </table>
  </div>

  <script>
    const runBtn = document.getElementById("runBtn");
    const stopBtn = document.getElementById("stopBtn");
    const logBox = document.getElementById("logBox");
    const resultTable = document.getElementById("resultTable");
    const resultBody = resultTable.querySelector("tbody");
    const form = document.getElementById("totalForm");

    // === NAS CONFIG Logic ===
    const nasBox = document.getElementById("nasConfigBox");
    const flopsSlider = document.getElementById("flopsSlider");
    const flopsValue = document.getElementById("flopsValue");
    const flopsHidden = document.getElementById("budgetFlopsHidden");

    const flopsSmall = document.getElementById("flopsSmall");
    const flopsMedium = document.getElementById("flopsMedium");
    const flopsLarge = document.getElementById("flopsLarge");

    // â‘  Network ì„ íƒ ë³€í™” ê°ì§€ â†’ Zero-shot ì‹œ NAS Config í‘œì‹œ
    const networkRadios = document.querySelectorAll("input[name='network']");
    networkRadios.forEach(radio => {
      radio.addEventListener("change", () => {
        if (radio.value === "zeroshot" && radio.checked) {
          nasBox.style.display = "block";
        } else if (radio.checked) {
          nasBox.style.display = "none";
        }
      });
    });

    // â‘¡ ìŠ¬ë¼ì´ë” ê°’ ì—…ë°ì´íŠ¸
    flopsSlider.addEventListener("input", () => {
      const val = flopsSlider.value;
      flopsValue.textContent = `Current: ${val}e6`;
      flopsHidden.value = `${val}e6`;
    });

    // â‘¢ ë²„íŠ¼ í´ë¦­ ì‹œ ìŠ¬ë¼ì´ë” ì´ë™
    flopsSmall.onclick = () => {
      flopsSlider.value = 450;
      flopsValue.textContent = "Current: 450e6";
      flopsHidden.value = "450e6";
    };
    flopsMedium.onclick = () => {
      flopsSlider.value = 600;
      flopsValue.textContent = "Current: 600e6";
      flopsHidden.value = "600e6";
    };
    flopsLarge.onclick = () => {
      flopsSlider.value = 1000;
      flopsValue.textContent = "Current: 1000e6";
      flopsHidden.value = "1000e6";
    };


    let isRunning = false;
    let stopRequested = false;

    // runBtn.onclick = async () => {
    //   if (isRunning) return;
    //   isRunning = true;
    //   stopRequested = false;

    //   // âœ… ë¡œê·¸ ì™„ì „ ì´ˆê¸°í™”
    //   logBox.innerHTML = "";
    //   resultTable.style.display = "none";
    //   resultBody.innerHTML = "";

    //   logLine("ğŸš€ Running YSAutoML Total Pipeline...");

    //   const formData = new FormData(form);
    //   const selectedData = formData.getAll("data");
    //   const network = formData.get("network");
    //   const optimization = formData.get("optimization");
    //   const model = formData.get("model");

    //   // Stage 1
    //   if (await stageCheck(`[Stage 1] Running ${network} search for ${model}...`, 2000)) return;
    //   addRow("Network Search", "Done", `ckpt_best_${network}.pth`);

    //   // Stage 2
    //   for (const d of selectedData) {
    //     if (await stageCheck(`[Stage 2] Applying Data Method: ${d.toUpperCase()}...`, 1500)) return;
    //     addRow(`Data: ${d.toUpperCase()}`, "Applied", `processed_${d}.json`);
    //   }

    //   // Stage 3
    //   if (await stageCheck(`[Stage 3] Running ${optimization} optimization...`, 2500)) return;
    //   addRow("Optimization", "Done", `final_${optimization}.pth`);

    //   logLine(`âœ… Total Pipeline Finished Successfully.`);
    //   resultTable.style.display = "table";
    //   isRunning = false;
    // };
    runBtn.onclick = async () => {
      logBox.innerHTML = "ğŸš€ Running YSAutoML Total Pipeline...\n";
      resultTable.style.display = "none";
      resultBody.innerHTML = "";

      const formData = new FormData(form);
      const body = {};
      formData.forEach((v, k) => (body[k] = v));

      const response = await fetch("/run_total_pipeline/", {
        method: "POST",
        headers: { "Content-Type": "application/json", "X-CSRFToken": getCookie("csrftoken") },
        body: JSON.stringify(body),
      });

      if (!response.ok) {
        logBox.innerHTML += "âŒ Failed to start pipeline.\n";
        return;
      }

      // âœ… ìŠ¤íŠ¸ë¦¬ë° ë¡œê·¸ ì½ê¸°
      const reader = response.body.getReader();
      const decoder = new TextDecoder("utf-8");
      let buffer = "";

      let downloadAdded = false;  // âœ… ì¤‘ë³µ ë°©ì§€ìš© flag

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        const chunk = decoder.decode(value, { stream: true });
        buffer += chunk;
        logBox.innerHTML += chunk;
        logBox.scrollTop = logBox.scrollHeight;

        // âœ… ë‹¤ìš´ë¡œë“œ ê²½ë¡œ ê°ì§€ (í•œ ë²ˆë§Œ ì¶”ê°€)
        const match = buffer.match(/\[DOWNLOAD_READY\] (.+)/);
        if (match && !downloadAdded) {
          const filePath = match[1].trim();
          const fileUrl = `/download_file/?path=${encodeURIComponent(filePath)}`;
          addRow(
            "Best Architecture",
            "Ready",
            `<a href="${fileUrl}" target="_blank">Download best_structure.txt</a>`
          );
          resultTable.style.display = "table";
          downloadAdded = true; // âœ… í•œ ë²ˆë§Œ ì‹¤í–‰ë˜ê²Œ í•¨

          await visualizeModelGraph(filePath);
          
          await runFXPTrainingAutomatically();

          if (data.url) {
            const box = document.getElementById("modelGraphBox");
            const img = document.getElementById("modelGraphImage");
            img.src = data.url + "?t=" + new Date().getTime();
            box.style.display = "block";
            logLine(`âœ… Model visualization ready: ${data.url}`);

            // âœ… FXP ì‹¤í–‰ ë°•ìŠ¤ í™œì„±í™”
            document.getElementById("fxpUploadBox").style.display = "block";
          }


        }
      }
    };


    stopBtn.onclick = () => {
      if (isRunning) {
        stopRequested = true;
        logLine("â›” Process stopped by user.");
      } else {
        logLine("âš ï¸ No process is currently running.");
      }
    };

    const graphBox = document.getElementById("graphViewerWrapper");
    const graphImg = document.getElementById("modelGraphImage");

    let scale = 1;
    let isDragging = false;
    let startX, startY, translateX = 0, translateY = 0;

    graphBox.addEventListener("wheel", (e) => {
      e.preventDefault();
      const delta = e.deltaY < 0 ? 0.1 : -0.1;
      scale = Math.min(Math.max(0.5, scale + delta), 5); // 0.5x ~ 5x
      updateTransform();
    });

    graphBox.addEventListener("mousedown", (e) => {
      isDragging = true;
      startX = e.clientX - translateX;
      startY = e.clientY - translateY;
      graphBox.style.cursor = "grabbing";
    });

    graphBox.addEventListener("mouseup", () => {
      isDragging = false;
      graphBox.style.cursor = "grab";
    });

    graphBox.addEventListener("mouseleave", () => {
      isDragging = false;
      graphBox.style.cursor = "grab";
    });

    graphBox.addEventListener("mousemove", (e) => {
      if (!isDragging) return;
      translateX = e.clientX - startX;
      translateY = e.clientY - startY;
      updateTransform();
    });

    function updateTransform() {
      graphImg.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
    }


    async function stageCheck(message, delay) {
      logLine(message);
      await fakeDelay(delay);
      if (stopRequested) {
        logLine("â›” Process stopped.\n");
        isRunning = false;
        stopRequested = false;
        return true;
      }
      logLine(message.replace("Running", "Completed"));
      logLine("");
      return false;
    }

    function addRow(stage, status, pathHTML) {
      const row = document.createElement("tr");
      row.innerHTML = `<td>${stage}</td><td>${status}</td><td>${pathHTML}</td>`;
      resultBody.appendChild(row);
    }

    function logLine(text) {
      logBox.innerHTML += text + "\n";
      logBox.scrollTop = logBox.scrollHeight; // ìë™ ìŠ¤í¬ë¡¤
    }

    function fakeDelay(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }

    async function visualizeModelGraph(filePath) {
      logLine("ğŸ§  Generating model graph visualization...");
      const response = await fetch("/visualize_model_from_structure/", {
        method: "POST",
        headers: { "Content-Type": "application/json", "X-CSRFToken": getCookie("csrftoken") },
        body: JSON.stringify({ path: filePath }),
      });
      const data = await response.json();
      if (data.url) {
        const box = document.getElementById("modelGraphBox");
        const img = document.getElementById("modelGraphImage");
        img.src = data.url + "?t=" + new Date().getTime();
        box.style.display = "block";
        logLine(`âœ… Model visualization ready: ${data.url}`);
      } else {
        logLine("âš ï¸ Model visualization failed.");
      }
    }



    const fxpForm = document.getElementById("fxpForm");

    fxpForm.addEventListener("submit", async (e) => {
      e.preventDefault();

      logLine("âš™ï¸ Starting FXP training...");
      const formData = new FormData(fxpForm);

      // âœ… FYI / DSBN ì²´í¬ë°•ìŠ¤ ê°’ ê°€ì ¸ì˜¤ê¸°
      const dsbnChecked = document.querySelector("input[name='data'][value='dsbn']").checked;
      const fyiChecked = document.querySelector("input[name='data'][value='fyi']").checked;

      formData.set("dsbn", dsbnChecked ? "true" : "false");
      formData.set("fyi", fyiChecked ? "true" : "false");

      // âœ… best_structure.txt ê²½ë¡œëŠ” ì„œë²„ê°€ ìë™ ì°¸ì¡°í•˜ë¯€ë¡œ í”„ë¡ íŠ¸ì—ì„œ ì•ˆë³´ëƒ„

      const response = await fetch("/run_fxp_training/", {
        method: "POST",
        headers: { "X-CSRFToken": getCookie("csrftoken") },
        body: formData,
      });

      if (!response.ok) {
        logLine("âŒ FXP training failed to start.");
        return;
      }

      const reader = response.body.getReader();
      const decoder = new TextDecoder("utf-8");

      let buffer = "";
      let downloadAdded = false;

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        const chunk = decoder.decode(value, { stream: true });
        buffer += chunk;
        logBox.innerHTML += chunk;
        logBox.scrollTop = logBox.scrollHeight;

        const match = buffer.match(/\[FXP_DONE\] (.+)/);
        if (match && !downloadAdded) {
          const pthPath = match[1].trim();
          const fileUrl = `/download_file/?path=${encodeURIComponent(pthPath)}`;
          addRow("FXP Optimization", "Done", `<a href="${fileUrl}" target="_blank">Download .pth</a>`);
          resultTable.style.display = "table";
          downloadAdded = true;
        }
      }
    });

    async function runFXPTrainingAutomatically() {
      console.log("ğŸ”¥ FXP auto run triggered");
      logLine("âš™ï¸ Auto FXP starting with hardcoded config...");

      // âœ… ì ˆëŒ€ê²½ë¡œ í•˜ë“œì½”ë”©
      const configPath = "/data1/hyunju/code/YonseiAutoML/ysautoml/optimization/fxp/engines/configs/mobilenet_2bit.yml";

      // âœ… DSBN/FYI ì²´í¬ ì—¬ë¶€
      const dsbnChecked = document.querySelector("input[name='data'][value='dsbn']").checked;
      const fyiChecked  = document.querySelector("input[name='data'][value='fyi']").checked;
      logLine(`âš™ï¸ DSBN=${dsbnChecked}, FYI=${fyiChecked}`);

      // âœ… FormData êµ¬ì„± (íŒŒì¼ ëŒ€ì‹  ê²½ë¡œ ë¬¸ìì—´ë§Œ ì „ì†¡)
      const formData = new FormData();
      formData.append("config_path", configPath);
      formData.append("dsbn", dsbnChecked ? "true" : "false");
      formData.append("fyi",  fyiChecked  ? "true" : "false");

      logLine(`ğŸ“„ Using config: ${configPath}`);

      // âœ… FXP ìš”ì²­
      const response = await fetch("/run_fxp_training/", {
        method: "POST",
        headers: { "X-CSRFToken": getCookie("csrftoken") },
        body: formData,
      });

      if (!response.ok) {
        logLine("âŒ FXP training failed to start.");
        return;
      }

      const reader = response.body.getReader();
      const decoder = new TextDecoder("utf-8");
      let buffer = "";
      let doneFlag = false;

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        const chunk = decoder.decode(value, { stream: true });
        buffer += chunk;
        logBox.innerHTML += chunk;
        logBox.scrollTop = logBox.scrollHeight;

        const match = buffer.match(/\[FXP_DONE\] (.+)/);
        if (match && !doneFlag) {
          const pthPath = match[1].trim();
          const url = `/download_file/?path=${encodeURIComponent(pthPath)}`;
          addRow("FXP Optimization", "Done", `<a href="${url}" target="_blank">Download .pth</a>`);
          resultTable.style.display = "table";
          doneFlag = true;
          logLine(`âœ… FXP done: ${pthPath}`);
        }
      }
    }


  </script>
</body>
</html>
